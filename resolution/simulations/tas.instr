/*******************************************************************************
* Instrument: tas instrument for resolution calculation
*
* %Identification
* Written by: Tobias Weber (tweber@ill.fr)
* Date: 30-Mar-2019
* Origin: ILL
* License: GPLv3
*
* %Description
*
* %End
*******************************************************************************/


DEFINE INSTRUMENT TAS
(
	/* source */
	double src_lam = 4.5, double src_dlam = 1.0,
	double src_k = -1.0, double src_E = -1.0,
	double src_rad = 0.01,

	/* monochromator */
	double ki = -1.0,
	double mono_mosaic = 30.0,
	double mono_d = 3.355,
	int mono_slabs_h = 32, int mono_slabs_v = 32,
	double mono_width = 0.1, double mono_height = 0.1,
	string mono_R = "HOPG.rfl", string mono_T = "HOPG.trm",
	double mono_angle = -1.0,

	/* horizontal and vertical curvatures, -1: optimal, 0: flat */
	double mono_curvh = -1.0,
	double mono_curvv = -1.0,

	/* analyser */
	double kf = -1.0,
	double ana_mosaic = 30.0,
	double ana_d = 3.355,
	int ana_slabs_h = 32, int ana_slabs_v = 32,
	double ana_width = 0.1, double ana_height = 0.1,
	string ana_R = "HOPG.rfl", string ana_T = "HOPG.trm",
	double ana_angle = -1.0,

	/* horizontal and vertical curvatures, -1: optimal, 0: flat */
	double ana_curvh = -1.0,
	double ana_curvv = -1.0,

	/* sample */
	double sample_rad = 0.01,
	double sample_height = 0.02,
	double sample_sc_angle = 53.48,

	/* detector */
	double det_width = 0.1, double det_height = 0.1,
	double monitor_width = 0.25, double monitor_height = 0.25,

	/* horizonal collimator divergences */
	double coll_premono_div_h = 9999.0,
	double coll_presample_div_h = 30.0,
	double coll_postsample_div_h = 30.0,
	double coll_postana_div_h = 9999.0,

	/* vertical collimator divergences */
	double coll_premono_div_v = 9999.0,
	double coll_presample_div_v = 9999.0,
	double coll_postsample_div_v = 9999.0,
	double coll_postana_div_v = 9999.0,

	double colli_len = 0.1,
	double colli_width = 0.1, double colli_height = 0.1,

	/* distances */
	double dist_src_mono = 1.0,
	double dist_mono_monitor = 0.75,
	double dist_mono_sample = 1.0,
	double dist_sample_ana = 1.0,
	double dist_ana_det = 1.0,

	double k_filter_cutoff = -1.0
)


DECLARE
%{
	/* flux after the monochromator and at the detector, respectively */
	double p_ki = 0., p_kf = 0.;

	/* ----------------------------------------------------------------------------- */
	/* Helper functions */
	/* ----------------------------------------------------------------------------- */
	double lam_to_k(double lam)
	{
		return 2.*PI / lam;
	}

	double k_to_lam(double k)
	{
		return 2.*PI / k;
	}

	double v_to_k(double v)
	{
		double p = v * MNEUTRON;
		double k = p / (HBAR*1e10);
		return k;
	}

	double lam_to_v(double lam)
	{
		double k = lam_to_k(lam);
		double p = HBAR * k*1e10;
		return p / MNEUTRON;
	}

	double lam_to_E(double lam)
	{
		double v = lam_to_v(lam);
		return v*v * VS2E;
	}

	double bragg_angle(double lam, double d)
	{
		double dS = lam / (2.*d);
		return asin(dS) * 180. / PI;
	}

	double foc_vert(double angle, double f)
	{
		return 2.*f * fabs(sin(angle));
	}

	double foc_hori(double angle, double f)
	{
		return 2.*f / fabs(sin(angle));
	}
	/* ----------------------------------------------------------------------------- */
%}


INITIALIZE
%{
	/* energy & angle */
	if(src_k < 0.)
		src_k = lam_to_k(src_lam);
	if(src_E < 0.)
		src_E = lam_to_E(src_lam);

	if(ki < 0)		/* if ki < 0 use source wavenumber */
		ki = src_k;
	if(mono_angle < 0.)
		mono_angle = bragg_angle(k_to_lam(ki), mono_d);

	if(kf < 0)		/* if kf < 0 use source wavenumber */
		kf = src_k;
	if(ana_angle < 0.)
		ana_angle = bragg_angle(k_to_lam(kf), ana_d);

	/* negative values -> optimal monochromator curvatures */
	if(mono_curvv < 0. || mono_curvh < 0.) {
		/* focal length */
		double f_inv = 1./dist_mono_sample + 1./dist_src_mono;

		if(mono_curvv < 0.)
			mono_curvv = foc_vert(mono_angle/180.*PI, 1./f_inv);
		if(mono_curvh < 0.)
			mono_curvh = foc_hori(mono_angle/180.*PI, 1./f_inv);
	}

	/* negative values -> optimal analyser curvatures */
	if(ana_curvv < 0. || ana_curvh < 0.) {
		/* focal length */
		double f_inv = 1./dist_ana_det + 1./dist_sample_ana;

		if(ana_curvv < 0.)
			ana_curvv = foc_vert(ana_angle/180.*PI, 1./f_inv);
		if(ana_curvh < 0.)
			ana_curvh = foc_hori(ana_angle/180.*PI, 1./f_inv);
	}

	printf("--------------------------------------------------------------------------------\n");
	printf("Source: lambda = %.4f A, k = %.4f 1/A, E = %.4f meV\n", src_lam, src_k, src_E);
	printf("Monochromator: ki = %.4f, theta = %.4f deg, d = %.4f, vfoc = %.4f m, hfoc = %.4f m\n",
		ki, mono_angle, mono_d, mono_curvv, mono_curvh);
	printf("Analyser: kf = %.4f, theta = %.4f deg, d = %.4f, vfoc = %.4f m, hfoc = %.4f m\n",
		kf, ana_angle, ana_d, ana_curvv, ana_curvh);
	printf("Sample: 2theta = %.4f\n", sample_sc_angle);
	printf("--------------------------------------------------------------------------------\n");
%}



/* ----------------------------------------------------------------------------- */
TRACE

COMPONENT origin = Progress_bar()
AT (0, 0, 0) ABSOLUTE




/* ----------------------------------------------------------------------------- */
/* Source */
/* ----------------------------------------------------------------------------- */
COMPONENT Src = Source_simple(
	radius = src_rad, lambda0 = src_lam, dlambda = src_dlam,
	gauss = 0, flux = 1e10, dist = dist_src_mono,
	focus_xw = mono_width*sin(mono_angle/180.0*PI), focus_yh = mono_height)
AT (0, 0, 0) RELATIVE PREVIOUS


COMPONENT colli_premono_h = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_premono_div_h)
AT (0, 0, dist_src_mono/2) RELATIVE Src
ROTATED (0, 0, 0) RELATIVE Src

COMPONENT colli_premono_v = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_premono_div_v)
AT (0, 0, dist_src_mono/2 + colli_len) RELATIVE Src
ROTATED (0, 0, 90) RELATIVE Src
/* ----------------------------------------------------------------------------- */



/* ----------------------------------------------------------------------------- */
/* Monochromator */
/* ----------------------------------------------------------------------------- */
COMPONENT mono_arm1 = Arm()
AT (0, 0, dist_src_mono) RELATIVE Src
ROTATED (0, 0, 0) RELATIVE Src


COMPONENT mono = Monochromator_curved(
	width = mono_width, height = mono_height,
	DM = mono_d, mosaic = mono_mosaic,
	NH = mono_slabs_h, NV = mono_slabs_v,
	RV = -mono_curvv, RH = -mono_curvh,
	r0 = 1, reflect = mono_R, t0 = 1, transmit = mono_T,
	order = 0)
AT (0, 0, 0) RELATIVE mono_arm1
ROTATED (0, -mono_angle, 0) RELATIVE mono_arm1
EXTEND
%{
	if(!SCATTERED)
		ABSORB;
%}



COMPONENT mono_arm2 = Arm()
AT (0, 0, 0) RELATIVE mono_arm1
ROTATED (0, -2*mono_angle, 0) RELATIVE mono_arm1


COMPONENT colli_presample_h = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_presample_div_h)
AT (0, 0, dist_mono_sample/2) RELATIVE mono_arm2
ROTATED (0, 0, 0) RELATIVE mono_arm2

COMPONENT colli_presample_v = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_presample_div_v)
AT (0, 0, dist_mono_sample/2 + colli_len) RELATIVE mono_arm2
ROTATED (0, 0, 90) RELATIVE mono_arm2


COMPONENT psdmon_ki = PSD_monitor(
	nx = 128, ny = 128,
	filename = "psd_ki.dat",
	xwidth = monitor_width, yheight = monitor_height,
	restore_neutron = 1)
AT (0, 0, dist_mono_monitor) RELATIVE mono_arm2
EXTEND
%{
	if(SCATTERED &&
		x >= -instrument->_parameters.monitor_width*0.5 && x <= instrument->_parameters.monitor_width*0.5 &&
		y >= -instrument->_parameters.monitor_height*0.5 && y <= instrument->_parameters.monitor_height*0.5)
	{
		p_ki += p;
	}
%}
/* ----------------------------------------------------------------------------- */



/* ----------------------------------------------------------------------------- */
/* Sample */
/* ----------------------------------------------------------------------------- */
COMPONENT sample_arm1 = Arm()
AT(0, 0, dist_mono_sample) RELATIVE mono_arm2
ROTATED (0, 0, 0) RELATIVE mono_arm2


COMPONENT sample_reso = Res_sample(
	radius = sample_rad, yheight = sample_height,
	E0 = src_E, dE = src_E*0.2,
	target_index = +4 /*analyser*/, focus_xw = ana_width, focus_yh = ana_height)
AT (0, 0, 0) RELATIVE sample_arm1
EXTEND
%{
	if(!SCATTERED)
		ABSORB;
%}



COMPONENT sample_arm2 = Arm()
AT (0, 0, dist_mono_sample) RELATIVE mono_arm2
ROTATED (0, sample_sc_angle, 0) RELATIVE mono_arm2



EXTEND
%{
	/* wavelength filter */
	if(INSTRUMENT_GETPAR(k_filter_cutoff) >= 0. &&
		v_to_k(sqrt(vx*vx + vy*vy + vz*vz)) > INSTRUMENT_GETPAR(k_filter_cutoff))
		ABSORB;
%}



COMPONENT colli_postsample_h = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_postsample_div_h)
AT (0, 0, dist_sample_ana/2) RELATIVE sample_arm2
ROTATED (0, 0, 0) RELATIVE sample_arm2

COMPONENT colli_postsample_v = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_postsample_div_v)
AT (0, 0, dist_sample_ana/2 + colli_len) RELATIVE sample_arm2
ROTATED (0, 0, 90) RELATIVE sample_arm2
/* ----------------------------------------------------------------------------- */



/* ----------------------------------------------------------------------------- */
/* Analyser */
/* ----------------------------------------------------------------------------- */
COMPONENT ana_arm1 = Arm()
AT (0, 0, dist_sample_ana) RELATIVE sample_arm2
ROTATED (0, 0, 0) RELATIVE sample_arm2


COMPONENT ana = Monochromator_curved(
	width = ana_width, height = ana_height,
	DM = ana_d, mosaic = ana_mosaic,
	NH = ana_slabs_h, NV = ana_slabs_v,
	RV = -ana_curvv, RH = -ana_curvh,
	r0 = 1, reflect = ana_R, t0 = 1, transmit = ana_T,
	order = 0)
AT (0, 0, 0) RELATIVE ana_arm1
ROTATED (0, -ana_angle, 0) RELATIVE ana_arm1
EXTEND
%{
	if(!SCATTERED)
		ABSORB;
%}


COMPONENT ana_arm2 = Arm()
AT (0, 0, 0) RELATIVE ana_arm1
ROTATED (0, -2*ana_angle, 0) RELATIVE ana_arm1



COMPONENT colli_postana_h = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_postana_div_h)
AT (0, 0, dist_ana_det/2) RELATIVE ana_arm2
ROTATED (0, 0, 0) RELATIVE ana_arm2

COMPONENT colli_postana_v = Collimator_linear(
	xwidth = colli_width, yheight = colli_height, length = colli_len,
	divergence = coll_postana_div_v)
AT (0, 0, dist_ana_det/2 + colli_len) RELATIVE ana_arm2
ROTATED (0, 0, 90) RELATIVE ana_arm2
/* ----------------------------------------------------------------------------- */



/* ----------------------------------------------------------------------------- */
/* Detectors */
/* ----------------------------------------------------------------------------- */
COMPONENT psdmon = PSD_monitor(
	nx = 128, ny = 128,
	filename = "psd.dat",
	xwidth = det_width, yheight = det_height,
	restore_neutron = 1)
AT (0, 0, dist_ana_det) RELATIVE ana_arm2
EXTEND
%{
	if(SCATTERED &&
		x >= -instrument->_parameters.det_width*0.5 && x <= instrument->_parameters.det_width*0.5 &&
		y >= -instrument->_parameters.det_height*0.5 && y <= instrument->_parameters.det_height*0.5)
	{
		p_kf += p;
	}
%}

COMPONENT resmon = Res_monitor(
	res_sample_comp = "sample_reso",
	filename = "reso.dat",
	xwidth = det_width, yheight = det_height,
	restore_neutron = 1)
AT (0, 0, 0) RELATIVE PREVIOUS
/* ----------------------------------------------------------------------------- */


FINALLY
%{
	/* output R0 normalised to flux at ki monitor  */
	printf("p_ki = %g, p_kf = %g, R0 = %g\n",
		p_ki, p_kf, p_kf/p_ki);
%}


END
